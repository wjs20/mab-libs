import functools
import itertools as it
import operator
import random
from typing import Any, Dict, Iterator, List, Sequence, Tuple, Union

Mutation = Tuple[int, str]


class RandomizationStrategy:
    """
    Class contains methods for generating all posible mutations that would result
    from a given randomization strategy. The mutations generated by this class can
    be used to create the proposed library in silico so that it can be analyzed
    and/or prefiltered before being sent for synthesis.
    """

    position_getter = operator.itemgetter(0)  # (0, 'A') -> 0

    def __init__(
        self,
        position_residue_mapping: Dict[int, str],
        n: Union[None, int] = None,
    ) -> None:
        """
        Args:
            position_residue_mapping (dict): A dictionary mapping positions to
            amino acid substitutions. e.g.

                {
                    1: ['A, 'D' ..., 'V', 'W'],
                    3: ['A, 'D' ..., 'V', 'W']
                }

            n (Union[None, int]): number of positions to mutate at one time. If None,
            n defaults to the number of positions specified in the position_residue_mapping
            and all positions will be mutated simultaneously.
        """
        self.position_residue_mapping = position_residue_mapping
        self.n = n or len(position_residue_mapping)

    def _get_position_residue_pairs(self) -> Iterator[Mutation]:
        """
        Method to convert position residue mapping dict into iterator of mutation
        tuples (position, residue) e.g.

            {
                1: ['A, 'D' ..., 'V', 'W'],
                3: ['A, 'D' ..., 'V', 'W']
            }

            ->

            (1,'A'), (1,'D'), ..., (3, 'V'), (3, 'W')
        """
        return it.chain.from_iterable(
            self.zip_keys_to_vals(self.position_residue_mapping)
        )

    def _group_by_position(
        self, mutations: Iterator[Mutation]
    ) -> List[List[Mutation]]:
        """
        Method groups mutations by position.

        Args:
            mutations (Iterator[Mutation]): an iterator containing mutations e.g.

            (1, 'A'), (1, 'D'), (2, 'A'), (2, 'D')

        Returns:
            List[List[Mutation]]: [(1, 'A'), (1, 'D')], [(2, 'A'), (2, 'D')]
        """

        return [
            list(g) for _, g in it.groupby(mutations, key=self.position_getter)
        ]

    def get_mutations(self) -> Iterator[Tuple[Mutation]]:
        """
        Method returns an Iterator of all unique n length combinations of mutations.
        """
        grouped_mutations = self._group_by_position(
            self._get_position_residue_pairs()
        )
        return it.chain.from_iterable(
            [it.product(*c) for c in it.combinations(grouped_mutations, self.n)]
        )

    def sample(
        self, k: int, seed: Union[int, None] = None
    ) -> Iterator[Tuple[Mutation]]:
        """
        Method takes a random sample of size k mutations from the total set of
        mutations. Useful for investigating properties of very large libraries.

        Args:
            k (int): sample size

        Returns:
            Iterator[Tuple[Mutation]]: a sample of mutations
        """
        mutations = self.get_mutations()
        library_idxs = range(0, len(self))

        if seed:
            random.seed(42)

        sample_indices = set(random.choices(library_idxs, k=k))
        for i, mutation in enumerate(mutations):
            if i in sample_indices:
                yield mutation

    def __len__(self) -> int:
        """
        Dunder method returns the total library size for the specified randomization strategy.

        Returns (int):
            library size (number of unique sequences)
        """
        return sum(
            self.mul_lens(residues)
            for residues in it.combinations(
                self.position_residue_mapping.values(), self.n
            )
        )

    @staticmethod
    def zip_keys_to_vals(
        position_residue_mapping: Dict[int, List[str]]
    ) -> List[List[Mutation]]:
        """
        Method converts a dict to a list such that items in each value list are
        each paired with their key e.g.


        {
            1: ['A, 'D' ..., 'V', 'W'],
            3: ['A, 'D' ..., 'V', 'W']
        }

        ->

        [
            [(1, 'A'), (1, 'D'), ..., (1, 'V'), (1, 'W')],
            [(3, 'A'), (3, 'D'), ..., (3, 'V'), (3, 'W')]
        ]

        Used to create the input for _create_combinations class method.
        """
        return [
            list(it.zip_longest([position], residues, fillvalue=position))
            for position, residues in position_residue_mapping.items()
        ]

    @staticmethod
    def mul_lens(iterable: Sequence[Sequence[Any]]) -> int:
        """
        Helper method to multiply together the lengths of a collection of
        iterables

        Args:
            iterator (Sequence[Sequence[Any]]): an iterable of iterables e.g.
            [(1, 2, 3), (1, 2, 3)]

        Returns:
            int: the product of the lengths of all the iterables

        """
        return functools.reduce(operator.mul, [len(i) for i in iterable])
